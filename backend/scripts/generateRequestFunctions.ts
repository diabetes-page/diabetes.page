import * as fs from 'fs';

const DOMAINS_DIR = './src/domains';
const ROUTES_DIR = '/routes';
const OUTPUT_FILE = '../frontend/src/utilities/requests/requests.ts';

class RequestFinder {
  private output =
    '/**\n' +
    ' * This file was autogenerated using the route definitions from the backend.\n' +
    ' */\n' +
    'import { AxiosResponse } from "axios";\n' +
    'import {Get, Post, Put, Patch, Delete, withAuth} from "./axios";';

  public run(): RequestFinder {
    fs.readdirSync(DOMAINS_DIR).forEach((domain) => this.parseDomain(domain));

    return this;
  }

  public write(): void {
    fs.writeFileSync(OUTPUT_FILE, this.output);
    console.log('Wrote to ' + OUTPUT_FILE);
  }

  private parseDomain(domain: string): void {
    const baseDir = `${DOMAINS_DIR}/${domain}${ROUTES_DIR}`;
    if (!fs.existsSync(baseDir)) {
      return;
    }
    fs.readdirSync(baseDir).forEach((route) => this.parseRoute(route, baseDir));
  }

  private parseRoute(route: string, baseDir: string): void {
    const dir = `${baseDir}/${route}`;
    const [requestType, routeUrl, urlParams] = this.parseRouteDefinition(
      route,
      dir,
    );
    const parameters = this.parseParameterDefinition(dir);
    const requestArgs = urlParams.map((p) => `${p}: number`);
    let requestDefinition = '\n\n';

    if (parameters) {
      requestDefinition +=
        `type ${capitalize(route)}Parameters = { 
      ${parameters}
};` + '\n';

      requestArgs.push(`params: ${capitalize(route)}Parameters `);
    }

    requestDefinition += `export const ${route} = (${requestArgs.join(
      ', ',
    )}): Promise<AxiosResponse> => ${requestType}(${routeUrl}${
      parameters ? ', params' : ''
    }, withAuth());`;

    this.output += requestDefinition;
  }

  private parseRouteDefinition(
    route: string,
    dir: string,
  ): [string, string, string[]] {
    const path = `${dir}/${capitalize(route)}.ts`;
    const contents = fs.readFileSync(path, 'utf8');

    const routeUrlRegex = /@(Get|Post|Put|Patch|Delete)\('([^']*)'\)/;
    const routeUrlRegexMatch = contents.match(routeUrlRegex);
    if (!routeUrlRegexMatch) {
      throw new Error('Could not find route url in path: ' + path);
    }
    const requestType = routeUrlRegexMatch[1];
    const routeUrlWithParams = routeUrlRegexMatch[2];

    const urlParams: string[] = [];
    const urlParamsRegex = /:([^/]+)/g;
    const routeUrl =
      '`' +
      routeUrlWithParams.replace(urlParamsRegex, (_: any, match: string) => {
        urlParams.push(match);
        return '${' + match + '}';
      }) +
      '`';

    return [requestType, routeUrl, urlParams];
  }

  private parseParameterDefinition(dir: string): string | undefined {
    const path = `${dir}/Parameters.ts`;
    if (!fs.existsSync(path)) {
      return;
    }
    const contents = fs.readFileSync(path, 'utf8');
    const regex = /class\s+Parameters[^\{]+{([\s\S]+)}/;
    const regexMatch = contents.match(regex);
    if (!regexMatch) {
      throw new Error('Could not find parameters in path: ' + path);
    }
    const paramsWithDecorators = regexMatch[1];
    return paramsWithDecorators.replace(/\s*(?:@|\/\/).+/g, '');
  }
}

function capitalize(input: string): string {
  return input.charAt(0).toUpperCase() + input.slice(1);
}

new RequestFinder().run().write();
